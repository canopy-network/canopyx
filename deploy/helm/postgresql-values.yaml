# PostgreSQL configuration for Temporal
# Bitnami PostgreSQL chart values
# Optimized for Temporal's high-write, high-connection workload

auth:
  username: temporal
  password: temporal
  database: temporal

primary:
  persistence:
    enabled: true
    size: 10Gi

  persistentVolumeClaimRetentionPolicy:
    enabled: true
    whenDeleted: Delete
    whenScaled: Retain

  # Resource limits tuned for Temporal workload
  # Assumes local dev with ~8-16GB RAM available
  resources:
    requests:
      memory: "2Gi"
      cpu: "1000m"
    limits:
      memory: "4Gi"
      cpu: "2000m"

  # PostgreSQL configuration overrides
  # These settings optimize for Temporal's write-heavy workflow execution patterns
  extendedConfiguration: |-
    # Connection settings
    max_connections = 300                    # Temporal creates many connections (frontend, history, matching, worker services)

    # Memory settings (tuned for 2-4GB container)
    shared_buffers = 512MB                   # 25% of 2GB allocation - cached data pages
    effective_cache_size = 2GB               # Hint for query planner - 50% of available memory
    work_mem = 8MB                           # Per-operation memory (sorts, hash joins) - 300 connections * 8MB = 2.4GB max
    maintenance_work_mem = 256MB             # For VACUUM, CREATE INDEX, etc

    # WAL (Write-Ahead Log) settings - critical for write performance
    wal_buffers = 16MB                       # Buffer for WAL before flushing to disk
    min_wal_size = 1GB                       # Minimum WAL size to keep
    max_wal_size = 4GB                       # Maximum WAL size before checkpoint
    checkpoint_completion_target = 0.9       # Spread checkpoint I/O over 90% of checkpoint interval

    # Query planner settings
    random_page_cost = 1.1                   # Low value for SSD/NVMe storage (default 4.0 is for spinning disks)
    effective_io_concurrency = 200           # Number of concurrent I/O operations (high for SSD)

    # Logging (reduce for production, increase for debugging)
    log_min_duration_statement = 1000        # Log queries slower than 1s
    log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '

    # Autovacuum tuning for high-write workload
    autovacuum_max_workers = 4               # More workers to keep up with writes
    autovacuum_naptime = 10s                 # Check more frequently (default 1min)
    autovacuum_vacuum_scale_factor = 0.05    # Vacuum when 5% of table changes (default 20%)
    autovacuum_analyze_scale_factor = 0.02   # Analyze when 2% of table changes (default 10%)

    # Parallel query settings
    max_worker_processes = 8                 # Total background workers
    max_parallel_workers_per_gather = 4      # Workers per query
    max_parallel_workers = 8                 # Max parallel workers for all queries

    # Lock management
    max_locks_per_transaction = 128          # Temporal creates many locks during workflow execution

    # Background writer tuning
    bgwriter_delay = 200ms                   # Background writer sleep between rounds
    bgwriter_lru_maxpages = 100              # Max pages to flush per round
    bgwriter_lru_multiplier = 2.0            # Multiplier for estimating next round

  # Initialize Temporal schemas
  # Temporal requires separate schemas for different services
  initdb:
    scripts:
      init-temporal-schemas.sql: |
        -- Create separate databases for Temporal services
        -- This improves isolation and allows per-service connection tuning

        -- Temporal uses 'temporal' database by default
        -- Additional schemas are created within the same database

        -- Visibility schema (for workflow search/filtering)
        CREATE SCHEMA IF NOT EXISTS temporal_visibility;

        -- Grant permissions
        GRANT ALL PRIVILEGES ON DATABASE temporal TO temporal;
        GRANT ALL PRIVILEGES ON SCHEMA temporal_visibility TO temporal;