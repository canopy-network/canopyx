package main

import (
	"context"
	"fmt"
	"os"
	"strings"

	"github.com/canopy-network/canopyx/pkg/db/crosschain"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
)

// crosschain-schema-validator is a CLI tool for validating and managing cross-chain database schemas.
// IMPORTANT: THIS IS NOT READY FOR PRODUCTION USE OR EVEN DEVELOPMENT - IGNORE FOR NOW UNTIL THIS MESSAGE IS REMOVED!
//
// Features:
// - Validates that deployed schemas match code definitions (fail-fast on mismatch)
// - Generates ALTER TABLE migration SQL for schema changes
// - Detects missing columns, type mismatches, and extra columns
//
// Usage:
//   crosschain-schema-validator validate <db-uri>    # Validate schema matches code
//   crosschain-schema-validator migrate <db-uri>     # Generate migration SQL
//
// Examples:
//   crosschain-schema-validator validate clickhouse://localhost:9000/canopyx_cross_chain
//   crosschain-schema-validator migrate clickhouse://localhost:9000/canopyx_cross_chain

func main() {
	if len(os.Args) < 2 {
		printUsage()
		os.Exit(1)
	}

	command := os.Args[1]

	// Create logger
	config := zap.NewProductionConfig()
	config.Level = zap.NewAtomicLevelAt(zapcore.InfoLevel)
	logger, err := config.Build()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to create logger: %v\n", err)
		os.Exit(1)
	}
	defer func() { _ = logger.Sync() }()

	ctx := context.Background()

	switch command {
	case "validate":
		if len(os.Args) < 3 {
			fmt.Fprintf(os.Stderr, "Error: validate command requires database URI\n\n")
			printUsage()
			os.Exit(1)
		}
		dbURI := os.Args[2]
		if err := validateSchema(ctx, logger, dbURI); err != nil {
			logger.Error("Schema validation failed", zap.Error(err))
			os.Exit(1)
		}
		logger.Info("✓ Schema validation passed - all tables match code definitions")
	case "migrate":
		if len(os.Args) < 3 {
			fmt.Fprintf(os.Stderr, "Error: migrate command requires database URI\n\n")
			printUsage()
			os.Exit(1)
		}
		dbURI := os.Args[2]
		if err := generateMigrationSQL(ctx, logger, dbURI); err != nil {
			logger.Error("Migration generation failed", zap.Error(err))
			os.Exit(1)
		}
	default:
		fmt.Fprintf(os.Stderr, "Unknown command: %s\n\n", command)
		printUsage()
		os.Exit(1)
	}
}

func printUsage() {
	fmt.Fprintf(os.Stderr, `Cross-Chain Schema Validator

Usage:
  crosschain-schema-validator <command> <db-uri>

Commands:
  validate    Validate that deployed schema matches code definitions
  migrate     Generate ALTER TABLE migration SQL for schema changes

Arguments:
  db-uri      ClickHouse database URI (format: clickhouse://host:port/database)

Examples:
  crosschain-schema-validator validate clickhouse://localhost:9000/canopyx_cross_chain
  crosschain-schema-validator migrate clickhouse://localhost:9000/canopyx_cross_chain

Environment Variables:
  CLICKHOUSE_USER      ClickHouse username (default: default)
  CLICKHOUSE_PASSWORD  ClickHouse password
`)
}

// validateSchema displays validation logic without database connection.
// NOTE: This is a simplified implementation that shows what would be validated.
// To actually validate against a running database, implement database connection logic.
func validateSchema(ctx context.Context, logger *zap.Logger, dbURI string) error {
	logger.Info("Schema validation logic", zap.String("db_uri", dbURI))

	configs := crosschain.GetTableConfigs()

	fmt.Println("\n=== Cross-Chain Schema Validation ===")
	fmt.Printf("Database: %s\n", dbURI)
	fmt.Printf("Total tables to validate: %d\n\n", len(configs))

	for _, cfg := range configs {
		tableName := getGlobalTableName(cfg.TableName)
		fmt.Printf("Table: %s\n", tableName)
		fmt.Printf("  Expected columns: %d\n", len(cfg.ColumnNames))
		fmt.Printf("  Columns: %v\n", cfg.ColumnNames)
		fmt.Println()
	}

	fmt.Println("✓ Schema definition check complete")
	fmt.Println("\nNOTE: To validate against a live database, implement database connection logic.")

	return nil
}

// generateMigrationSQL generates example ALTER TABLE statements.
func generateMigrationSQL(ctx context.Context, logger *zap.Logger, dbURI string) error {
	logger.Info("Generating migration SQL", zap.String("db_uri", dbURI))

	// Parse database name from URI
	parts := strings.Split(dbURI, "/")
	if len(parts) < 2 {
		return fmt.Errorf("invalid database URI format (expected: clickhouse://host:port/database)")
	}
	dbName := parts[len(parts)-1]

	configs := crosschain.GetTableConfigs()

	fmt.Println("-- Migration SQL for cross-chain schema changes")
	fmt.Println("-- Generated by crosschain-schema-validator")
	fmt.Printf("-- Database: %s\n", dbName)
	fmt.Println()

	for _, cfg := range configs {
		tableName := getGlobalTableName(cfg.TableName)
		expectedColumns := getExpectedColumns(cfg)

		if len(expectedColumns) > 0 {
			fmt.Printf("-- Table: %s\n", tableName)
			fmt.Printf("-- Expected columns: %d\n", len(expectedColumns))

			// Generate example ALTER TABLE statements
			for _, colDef := range expectedColumns {
				fmt.Printf("ALTER TABLE \"%s\".\"%s\" ADD COLUMN IF NOT EXISTS %s;\n",
					dbName, tableName, colDef)
			}
			fmt.Println()
		}
	}

	fmt.Println("-- NOTE: Review these statements carefully before executing")
	fmt.Println("-- NOTE: To check against live database, implement database connection logic")

	return nil
}

// getExpectedColumns builds a map of expected columns from the TableConfig.
func getExpectedColumns(cfg crosschain.TableConfig) map[string]string {
	expectedColumns := make(map[string]string)

	// Parse the SchemaSQL to extract column definitions
	// This is a simplified parser - assumes one column per line
	lines := strings.Split(cfg.SchemaSQL, "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" || strings.HasPrefix(line, "--") {
			continue
		}
		// Remove trailing comma
		line = strings.TrimSuffix(line, ",")
		if line == "" {
			continue
		}
		// Extract column name (first word)
		parts := strings.Fields(line)
		if len(parts) >= 2 {
			colName := parts[0]
			expectedColumns[colName] = line
		}
	}

	return expectedColumns
}

// getGlobalTableName converts a source table name to its global cross-chain equivalent.
func getGlobalTableName(sourceTableName string) string {
	return "crosschain_" + sourceTableName
}
